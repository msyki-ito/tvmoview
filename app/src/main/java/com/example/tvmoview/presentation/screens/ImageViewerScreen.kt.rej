diff a/app/src/main/java/com/example/tvmoview/presentation/screens/ImageViewerScreen.kt b/app/src/main/java/com/example/tvmoview/presentation/screens/ImageViewerScreen.kt	(rejected hunks)
@@ -1,109 +1,117 @@
 ï»¿package com.example.tvmoview.presentation.screens
 
 import android.util.Log
 import androidx.activity.compose.BackHandler
 import androidx.compose.foundation.background
 import androidx.compose.foundation.focusable
 import androidx.compose.foundation.layout.*
 import androidx.compose.material.icons.Icons
 import androidx.compose.material.icons.filled.BrokenImage
 import androidx.compose.material3.*
-import androidx.compose.runtime.*
+import androidx.compose.runtime.*
+import androidx.compose.runtime.getValue
+import androidx.compose.runtime.setValue
 import androidx.compose.ui.Alignment
 import androidx.compose.ui.Modifier
 import androidx.compose.ui.focus.FocusRequester
 import androidx.compose.ui.focus.focusRequester
 import androidx.compose.ui.graphics.Color
 import androidx.compose.ui.input.key.*
 import androidx.compose.ui.layout.ContentScale
 import androidx.compose.ui.platform.LocalContext
 import androidx.compose.ui.unit.dp
 import coil.compose.SubcomposeAsyncImage
 import coil.request.ImageRequest
 import com.example.tvmoview.MainActivity
 import com.example.tvmoview.domain.model.MediaItem
 import kotlinx.coroutines.launch
 
 @Composable
 fun ImageViewerScreen(
     currentImageId: String,
     folderId: String? = null,
     onBack: () -> Unit
 ) {
     val focusRequester = remember { FocusRequester() }
     val scope = rememberCoroutineScope()
     val context = LocalContext.current
 
     var imageItems by remember { mutableStateOf<List<MediaItem>>(emptyList()) }
     var currentIndex by remember { mutableIntStateOf(0) }
     var isLoading by remember { mutableStateOf(true) }
-    var imageUrl by remember { mutableStateOf<String?>(null) }
+    var imageUrl by remember { mutableStateOf<String?>(null) }
+    val showInfo = remember { mutableStateOf(true) }
 
     Log.d("ImageViewer", "Screen started with imageId: $currentImageId, folderId: $folderId")
 
     LaunchedEffect(folderId) {
         isLoading = true
         try {
             val items = MainActivity.oneDriveRepository.getCachedItems(folderId)
                 .filter { it.isImage }
 
             Log.d("ImageViewer", "Found ${items.size} images")
             imageItems = items
 
             val foundIndex = items.indexOfFirst { it.id == currentImageId }
             currentIndex = if (foundIndex >= 0) foundIndex else 0
 
             Log.d("ImageViewer", "Current index: $currentIndex")
 
             if (items.isNotEmpty() && currentIndex >= 0 && currentIndex < items.size) {
                 val currentItem = items[currentIndex]
                 Log.d("ImageViewer", "Loading image: ${currentItem.name}")
 
                 val url = MainActivity.oneDriveRepository
                     .getDownloadUrl(currentItem.id)
                     ?: currentItem.downloadUrl
                 imageUrl = url
                 Log.d("ImageViewer", "Image URL: $url")
             }
         } catch (e: Exception) {
             Log.e("ImageViewer", "Error loading images", e)
         } finally {
             isLoading = false
         }
     }
 
     LaunchedEffect(currentIndex) {
         if (imageItems.isNotEmpty() && currentIndex >= 0 && currentIndex < imageItems.size) {
             scope.launch {
                 val currentItem = imageItems[currentIndex]
                 Log.d("ImageViewer", "Switching to image: ${currentItem.name}")
 
                 val url = MainActivity.oneDriveRepository
                     .getDownloadUrl(currentItem.id)
                     ?: currentItem.downloadUrl
                 imageUrl = url
+                showInfo.value = true
+                scope.launch {
+                    kotlinx.coroutines.delay(3000)
+                    showInfo.value = false
+                }
             }
         }
     }
 
     LaunchedEffect(Unit) {
         focusRequester.requestFocus()
     }
 
     BackHandler { onBack() }
 
     Box(
         modifier = Modifier
             .fillMaxSize()
             .background(Color.Black)
             .focusRequester(focusRequester)
             .focusable()
             .onKeyEvent { keyEvent ->
                 if (keyEvent.type == KeyEventType.KeyDown) {
                     when (keyEvent.key) {
                         Key.DirectionLeft -> {
                             if (currentIndex > 0) {
                                 currentIndex--
                                 Log.d("ImageViewer", "Navigate left to index: $currentIndex")
                             }
                             true
